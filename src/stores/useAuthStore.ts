import { create } from 'zustand'

import { getChallenge, verifySignature } from 'api'

import { AuthStore } from './types'
import { parseAuthError, validateToken } from './utils'

/**
 * Zustand store hook for managing the application's authentication state.
 *
 * @remarks
 * This store handles the authentication flow using Sign-In with Ethereum (SIWE) and JWT tokens.
 * It provides actions to:
 * - Handle authentication (`handleAuthentication`).
 * - Check for an existing JWT token (`checkExistingToken`).
 * - Log out the user (`logout`).
 * - Set authentication errors (`setAuthError`).
 */
export const useAuthStore = create<AuthStore>((set, get) => ({
  // ----- Initial state ----- //

  isAuthenticated: false,
  isAttemptingAuth: false,
  isSwitchingAccounts: false,
  authError: null,
  isLoggingOut: false,
  isNewUser: null,

  // ----- Handle authentication ----- //

  handleAuthentication: async (address, chainId, signMessageAsync, isConnected) => {
    if (get().isAttemptingAuth || get().isLoggingOut || !isConnected) {
      console.warn(
        `[AuthStore] Auth attempt prevented, ${
          get().isAttemptingAuth
            ? 'already attempting authentication'
            : get().isLoggingOut
              ? 'currently logging out'
              : !isConnected
                ? 'wallet not connected'
                : ''
        }`
      )
      return
    }
    set({ isAttemptingAuth: true, authError: null, isLoggingOut: false, isNewUser: null })

    // Skip SIWE if a valid token is found
    const token = localStorage.getItem('accessToken')
    const { isValid: isTokenValid } = validateToken({ token, address, chainId })
    if (isTokenValid) {
      console.log('[AuthStore] Existing token is valid. Skipping SIWE.')
      set({ isAuthenticated: true, isAttemptingAuth: false, isNewUser: false })
      return
    }

    // Proceed with SIWE
    console.log(`[AuthStore] Starting SIWE for ${address} on chain ${chainId}...`)
    if (token) localStorage.removeItem('accessToken')
    set({ isAuthenticated: false })

    try {
      // Cancellation Check 1
      if (get().isLoggingOut) throw new Error('Auth cancelled (logout)')

      // Generate SIWE message
      const message = await getChallenge(address, chainId)
      console.log('[AuthStore] Message generated by getChallenge:', message)

      // Cancellation Check 2
      if (get().isLoggingOut) throw new Error('Auth cancelled (logout)')

      // Ask user to sign the message
      const signature = await signMessageAsync({ message })

      // Cancellation Check 3
      if (get().isLoggingOut) throw new Error('Auth cancelled (logout)')

      // Verify SIWE signature and get access token
      const { accessToken, isNewUser } = await verifySignature({ message, signature, address })
      localStorage.setItem('accessToken', accessToken)

      // Cancellation Check 4
      if (get().isLoggingOut) {
        localStorage.removeItem('accessToken')
        throw new Error('Auth cancelled (logout)')
      }

      // Success
      set({ isAuthenticated: true, isAttemptingAuth: false, authError: null, isNewUser })
      console.log('[AuthStore] SIWE successful.')
    } catch (error: unknown) {
      // Handle cancellation errors
      if (error instanceof Error && error.message === 'Auth cancelled (logout)') {
        console.log('[AuthStore] Authentication flow cancelled by logout.')
      }

      // Handle actual errors
      else if (!get().isLoggingOut) {
        console.error('[AuthStore] Authentication flow error:', error)
        const { displayMessage } = parseAuthError(error)
        set({
          isAuthenticated: false,
          authError: displayMessage,
          isNewUser: null,
        })
        localStorage.removeItem('accessToken')
      } else {
        console.log('useAuthStore: Auth flow error caught during logout, ignoring.')
      }
    } finally {
      // Reset isAttemptingAuth state
      if (get().isAttemptingAuth) {
        set({ isAttemptingAuth: false })
      }
    }
  },

  // ---- Logout ----- //

  logout: () => {
    set({ isLoggingOut: true, isAttemptingAuth: false, isAuthenticated: false, authError: null, isNewUser: null })
    localStorage.removeItem('accessToken')
    set({ isLoggingOut: false })
    console.log('useAuthStore: User logged out successfully.')
  },

  // ----- Reset New User Flag ----- //

  resetNewUserFlag: () => {
    if (get().isNewUser === true) {
      set({ isNewUser: false })
    }
  },
}))

export default useAuthStore
